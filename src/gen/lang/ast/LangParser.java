package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short LPAR = 1;
		static public final short ID = 2;
		static public final short NUM = 3;
		static public final short RPAR = 4;
		static public final short PLUS = 5;
		static public final short MINUS = 6;
		static public final short INT = 7;
		static public final short LBRA = 8;
		static public final short SC = 9;
		static public final short MUL = 10;
		static public final short DIV = 11;
		static public final short MOD = 12;
		static public final short WHILE = 13;
		static public final short IF = 14;
		static public final short RBRA = 15;
		static public final short ASSIGN = 16;
		static public final short RETURN = 17;
		static public final short COMMA = 18;
		static public final short ELSE = 19;
		static public final short EQ = 20;
		static public final short NE = 21;
		static public final short LT = 22;
		static public final short LE = 23;
		static public final short GT = 24;
		static public final short GE = 25;

		static public final String[] NAMES = {
			"EOF",
			"LPAR",
			"ID",
			"NUM",
			"RPAR",
			"PLUS",
			"MINUS",
			"INT",
			"LBRA",
			"SC",
			"MUL",
			"DIV",
			"MOD",
			"WHILE",
			"IF",
			"RBRA",
			"ASSIGN",
			"RETURN",
			"COMMA",
			"ELSE",
			"EQ",
			"NE",
			"LT",
			"LE",
			"GT",
			"GE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pDbSbtL4KKXt$TwTW413LWW2GGoD0XeI7frYPC1WE8610G6GIZ22B7Vy4Tn#F6bNltxbs" +
		"wSUayuOYpE8CQ5H05f#ltwjt4b#VhW1kFtUUhU#jtg#whMrslMiezgANgqu2MgAH1LLJLGg" +
		"tGIgtHKMtHxide8eyUKa7prA0ktQlPcgDhTAskKxFcgbytwWRDh9DlVXszfuw#l8w#jOw#h" +
		"Ow#iuw#RqfrwpnsbSQeRaoDkZfLNJfBMyYILc$AL3TagYEPwgPCzPQWjcjjY7GGYNUxe1bw" +
		"mFrMhTUmRjP6RQQVLz7CdgMMnUfL3MLCjskFch2ZFcDrK6Pf0KgKTnbv8xjgCd$SnXcIIhB" +
		"jl4ny#lPwtHRg6Y9FMIt1JzEj#tIhjck7Tb7l7RfJUxLVT#4Vq44TqTruzy1XQhkVVMXZrY" +
		"9MrH7gwUIiTdFEIY6IZbRGIrHUe#v#JbqvxFG0#vvZ3njOOxry$qSz7IkeI7L5QabNbvtbl" +
		"rKRUTyc8l5kb$WLbxa$ZxFHmhsnW3SspqdfbJYPHMwOMRoTd6z$GukyeV6CWYjDA1Dvf#QF" +
		"spX3KfdQNYu#NTl4DwghGB$0xH7vQPf3f2cCc45TiTUBN#McQGvUFaIYNqywTbpX4vbnzn#" +
		"5X#6azq#xFNlS1qw7b5lbuxlWelidu7rYwx6du2lycOav7JINi1jWjcj5c9iOqm8ZLxY6XH" +
		"bQEym7rfNR2DIVsmnzi0NAi1K6O1GsGHM6V7uDjhc$1rR3RjZfsYwt1s0Tx8UziDtrWsuF9" +
		"zQq0yRSF$JFDUifRjfp4tryzatFk7$UnnovaZr9v9oJwZ$a#Ivu$#baF7gcwws9EMSIVkbV" +
		"F7iyGplgzX6tZxbztEqJRfzCpAac$E5Klj7OvYePpzhdiUYtBBk$DdkjkM6t8rDr7OkD$U7" +
		"sT$WLBjalTixEse$sWtrlu$OTshTXn1dxbFOKd8JNxLLxnUUUDzuAEs4lXzvBzfwzQs$RM$" +
		"QclM4lsWjehzdpzfpzXFSEV08VmqVm8NpWUKw7zclv9pedzkLaxmlxdFOp#COk1kKtk60$s" +
		"vzqrd3tvRW58$BSaGLev8R8G$GlbGl$#HLiXNuDMyFsXPi$ctx6bs0vkSgmWl4hoJc0DeWT" +
		"vAQgulSmjeTO5ft49kYYtmsByPDqe2s1fT1E$syQmhtS2cqylut#q5zAlqLt");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = func_list.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return new Program(l);
				}
			},
			new Action() {	// [1] func_list = func.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final Func f = (Func) _symbol_f.value;
					 return new List().add(f);
				}
			},
			new Action() {	// [2] func_list = func_list.l func.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_f = _symbols[offset + 2];
					final Func f = (Func) _symbol_f.value;
					 return l.add(f);
				}
			},
			new Action() {	// [3] func = idDecl.id LPAR RPAR block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final Block b = (Block) _symbol_b.value;
					 return new Func(id, new List(), b);
				}
			},
			new Action() {	// [4] func = idDecl.id LPAR param_list.l RPAR block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new Func(id, l, b);
				}
			},
			new Action() {	// [5] block = LBRA RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Block(new List());
				}
			},
			new Action() {	// [6] block = LBRA stmt_list.l RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new Block(l);
				}
			},
			new Action() {	// [7] stmt_list = stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new List().add(s);
				}
			},
			new Action() {	// [8] stmt_list = stmt_list.l stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Stmt s = (Stmt) _symbol_s.value;
					 return l.add(s);
				}
			},
			new Action() {	// [9] param_list = idDecl.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdDecl p = (IdDecl) _symbol_p.value;
					 return new List().add(p);
				}
			},
			new Action() {	// [10] param_list = param_list.l COMMA idDecl.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_p = _symbols[offset + 3];
					final IdDecl p = (IdDecl) _symbol_p.value;
					 return l.add(p);
				}
			},
			new Action() {	// [11] arg_list = expr.ex
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 1];
					final Expr ex = (Expr) _symbol_ex.value;
					 return new List().add(ex);
				}
			},
			new Action() {	// [12] arg_list = arg_list.l COMMA expr.ex
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_ex = _symbols[offset + 3];
					final Expr ex = (Expr) _symbol_ex.value;
					 return l.add(ex);
				}
			},
			Action.RETURN,	// [13] stmt = idDeclStmt
			Action.RETURN,	// [14] stmt = idDeclAss
			Action.RETURN,	// [15] stmt = assign
			Action.RETURN,	// [16] stmt = returnStmt
			Action.RETURN,	// [17] stmt = whileStmt
			Action.RETURN,	// [18] stmt = funcStmt
			Action.RETURN,	// [19] stmt = ifStmt
			new Action() {	// [20] idDeclStmt = idDecl.id SC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdDecl id = (IdDecl) _symbol_id.value;
					 return new IdDeclStmt(id);
				}
			},
			new Action() {	// [21] idDecl = INT ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 2];
					 return new IdDecl(id);
				}
			},
			new Action() {	// [22] idDeclAss = idDecl.id ASSIGN expr.ex SC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdDecl id = (IdDecl) _symbol_id.value;
					final Symbol _symbol_ex = _symbols[offset + 3];
					final Expr ex = (Expr) _symbol_ex.value;
					 return new IdDeclAss(id, ex);
				}
			},
			new Action() {	// [23] assign = idUse.id ASSIGN expr.ex SC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_ex = _symbols[offset + 3];
					final Expr ex = (Expr) _symbol_ex.value;
					 return new Assign(id, ex);
				}
			},
			new Action() {	// [24] returnStmt = RETURN expr.ex SC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 2];
					final Expr ex = (Expr) _symbol_ex.value;
					 return new ReturnStmt(ex);
				}
			},
			new Action() {	// [25] whileStmt = WHILE LPAR expr.ex RPAR block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 3];
					final Expr ex = (Expr) _symbol_ex.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new WhileStmt(ex, b);
				}
			},
			new Action() {	// [26] funcStmt = funcUse.id SC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final FuncUse id = (FuncUse) _symbol_id.value;
					 return new FuncStmt(id);
				}
			},
			new Action() {	// [27] ifStmt = IF LPAR expr.ex RPAR block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 3];
					final Expr ex = (Expr) _symbol_ex.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new IfStmt(ex, b, new Opt());
				}
			},
			new Action() {	// [28] ifStmt = IF LPAR expr.ex RPAR block.b elseStmt.el
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 3];
					final Expr ex = (Expr) _symbol_ex.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_el = _symbols[offset + 6];
					final ElseStmt el = (ElseStmt) _symbol_el.value;
					 return new IfStmt(ex, b, new Opt(el));
				}
			},
			new Action() {	// [29] elseStmt = ELSE block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new ElseStmt(b);
				}
			},
			Action.RETURN,	// [30] expr = addExpr
			new Action() {	// [31] expr = addExpr.e1 EQ addExpr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new Equals(e1, e2);
				}
			},
			new Action() {	// [32] expr = addExpr.e1 NE addExpr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NotEquals(e1, e2);
				}
			},
			new Action() {	// [33] expr = addExpr.e1 LT addExpr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LessThan(e1, e2);
				}
			},
			new Action() {	// [34] expr = addExpr.e1 LE addExpr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LessEqual(e1, e2);
				}
			},
			new Action() {	// [35] expr = addExpr.e1 GT addExpr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GreaterThan(e1, e2);
				}
			},
			new Action() {	// [36] expr = addExpr.e1 GE addExpr.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GreaterEqual(e1, e2);
				}
			},
			Action.RETURN,	// [37] addExpr = term
			Action.RETURN,	// [38] addExpr = add
			Action.RETURN,	// [39] addExpr = sub
			new Action() {	// [40] add = addExpr.ex PLUS term.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 1];
					final Expr ex = (Expr) _symbol_ex.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Expr t = (Expr) _symbol_t.value;
					 return new Add(ex, t);
				}
			},
			new Action() {	// [41] sub = addExpr.ex MINUS term.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ex = _symbols[offset + 1];
					final Expr ex = (Expr) _symbol_ex.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Expr t = (Expr) _symbol_t.value;
					 return new Sub(ex, t);
				}
			},
			Action.RETURN,	// [42] term = factor
			Action.RETURN,	// [43] term = mul
			Action.RETURN,	// [44] term = div
			Action.RETURN,	// [45] term = mod
			new Action() {	// [46] mul = term.t MUL factor.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Expr t = (Expr) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Expr f = (Expr) _symbol_f.value;
					 return new Mul(t, f);
				}
			},
			new Action() {	// [47] div = term.t DIV factor.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Expr t = (Expr) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Expr f = (Expr) _symbol_f.value;
					 return new Div(t, f);
				}
			},
			new Action() {	// [48] mod = term.t MOD factor.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Expr t = (Expr) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Expr f = (Expr) _symbol_f.value;
					 return new Mod(t, f);
				}
			},
			Action.RETURN,	// [49] factor = numeral
			Action.RETURN,	// [50] factor = idUse
			Action.RETURN,	// [51] factor = funcUse
			RETURN2,	// [52] factor = LPAR expr.ex RPAR
			new Action() {	// [53] numeral = NUM.num
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol num = _symbols[offset + 1];
					 return new Numeral(num);
				}
			},
			new Action() {	// [54] idUse = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol id = _symbols[offset + 1];
					 return new IdUse(id);
				}
			},
			new Action() {	// [55] funcUse = idUse.id LPAR arg_list.l RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new FuncUse(id, l);
				}
			},
			new Action() {	// [56] funcUse = idUse.id LPAR RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final IdUse id = (IdUse) _symbol_id.value;
					 return new FuncUse(id, new List());
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
